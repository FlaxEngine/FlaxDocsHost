<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Raycasting | Flax Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Raycasting | Flax Documentation ">
    <meta name="generator" content="docfx 2.58.9.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    <meta property="docfx:newtab" content="true">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@flaxengine">
    <meta name="og:title" content="Raycasting | Flax Documentation ">
    <meta property="og:image" content="https://docs.flaxengine.com/media/social-image.jpg">
  
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-88357703-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-88357703-2');
    </script>
  </head>	  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="https://www.flaxengine.com">
        		<div style="text-align:center; line-height:45px">
        	    <img id="logo" height="40" width="40" src="../../logo.png" alt="">
        		</div>
        	  </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="raycasting">Raycasting</h1>

<p>By using <strong>Raycasts</strong> game scripts can detect various geometry intersections. For instance, you can perform various overlap tests and raycasts to scan the space around the player. Probably the most common case is to use raycast to place a third-person camera right behind the player but without clipping the scene objects.</p>
<p>Flax provides various C# API for raycasting and geometry tests:</p>
<ul>
<li><a href="https://docs.flaxengine.com/api/FlaxEngine.Physics.html#FlaxEngine_Physics_RayCast_FlaxEngine_Vector3_FlaxEngine_Vector3_FlaxEngine_RayCastHit__System_Single_System_Int32_System_Boolean_">Physics.RayCast</a></li>
<li><a href="https://docs.flaxengine.com/api/FlaxEngine.Physics.html#collapsible-FlaxEngine_Physics_RayCastAll_FlaxEngine_Vector3_FlaxEngine_Vector3_System_Single_System_Int32_System_Boolean_">Physics.RayCastAll</a></li>
<li><a href="https://docs.flaxengine.com/api/FlaxEngine.Physics.html#FlaxEngine_Physics_BoxCast_FlaxEngine_Vector3_FlaxEngine_Vector3_FlaxEngine_Vector3_FlaxEngine_Quaternion_System_Single_System_Int32_System_Boolean_">Physics.BoxCast</a></li>
<li><a href="https://docs.flaxengine.com/api/FlaxEngine.Physics.html#FlaxEngine_Physics_BoxCastAll_FlaxEngine_Vector3_FlaxEngine_Vector3_FlaxEngine_Vector3_FlaxEngine_Quaternion_System_Single_System_Int32_System_Boolean_">Physics.BoxCastAll</a></li>
<li><a href="https://docs.flaxengine.com/api/FlaxEngine.Physics.html#FlaxEngine_Physics_SphereCast_FlaxEngine_Vector3_System_Single_FlaxEngine_Vector3_FlaxEngine_RayCastHit__System_Single_System_Int32_System_Boolean_">Physics.SphereCast</a></li>
<li><a href="https://docs.flaxengine.com/api/FlaxEngine.Physics.html#FlaxEngine_Physics_SphereCastAll_FlaxEngine_Vector3_System_Single_FlaxEngine_Vector3_System_Single_System_Int32_System_Boolean_">Physics.SphereCastAll</a></li>
<li><a href="https://docs.flaxengine.com/api/FlaxEngine.Physics.html#FlaxEngine_Physics_CheckBox_FlaxEngine_Vector3_FlaxEngine_Vector3_FlaxEngine_Quaternion_System_Int32_System_Boolean_">Physics.CheckBox</a></li>
<li><a href="https://docs.flaxengine.com/api/FlaxEngine.Physics.html#FlaxEngine_Physics_CheckSphere_FlaxEngine_Vector3_System_Single_System_Int32_System_Boolean_">Physics.CheckSphere</a></li>
<li><a href="https://docs.flaxengine.com/api/FlaxEngine.Physics.html#FlaxEngine_Physics_OverlapBox_FlaxEngine_Vector3_FlaxEngine_Vector3_FlaxEngine_Quaternion_System_Int32_System_Boolean_">Physics.OverlapBox</a></li>
<li><a href="https://docs.flaxengine.com/api/FlaxEngine.Physics.html#FlaxEngine_Physics_OverlapSphere_FlaxEngine_Vector3_System_Single_System_Int32_System_Boolean_">Physics.OverlapSphere</a></li>
</ul>
<p>Additionally you can perform similar tests for single collider using <a href="https://docs.flaxengine.com/api/FlaxEngine.Collider.html#FlaxEngine_Collider_RayCast_FlaxEngine_Vector3_FlaxEngine_Vector3_FlaxEngine_RayCastHit__System_Single_">Collider.RayCast</a> and <a href="https://docs.flaxengine.com/api/FlaxEngine.Collider.html#FlaxEngine_Collider_ClosestPoint_FlaxEngine_Vector3_">Collider.ClosestPoint</a> methods.</p>
<h2 id="example">Example</h2>
<p>This code sends a raycast from the object location and draws a red sphere at the hit location.</p>
<div class="tabGroup" id="tabgroup_Kfl9wdZikS">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_Kfl9wdZikS_code-csharp" role="tab" aria-controls="tabpanel_Kfl9wdZikS_code-csharp" data-tab="code-csharp" tabindex="0" aria-selected="true">C#</a>
</li>
<li role="presentation">
<a href="#tabpanel_Kfl9wdZikS_code-cpp" role="tab" aria-controls="tabpanel_Kfl9wdZikS_code-cpp" data-tab="code-cpp" tabindex="-1">C++</a>
</li>
</ul>
<section id="tabpanel_Kfl9wdZikS_code-csharp" role="tabpanel" data-tab="code-csharp">
<pre><code class="lang-cs">public override void OnUpdate()
{
    RayCastHit hit;
    if (Physics.RayCast(Actor.Position, Actor.Direction, out hit))
    {
        DebugDraw.DrawSphere(new BoundingSphere(hit.Point, 50), Color.Red);
    }
}
</code></pre></section>
<section id="tabpanel_Kfl9wdZikS_code-cpp" role="tabpanel" data-tab="code-cpp" aria-hidden="true" hidden="hidden">
<pre><code class="lang-cpp">#include &quot;Engine/Physics/Physics.h&quot;
#include &quot;Engine/Debug/DebugDraw.h&quot;

void MyScript::OnUpdate() override
{
    RayCastHit hit;
    if (Physics::RayCast(GetActor()-&gt;GetPosition(), GetActor()-&gt;GetDirection(), hit))
    {
        DEBUG_DRAW_SPHERE(BoundingSphere(hit.Point, 50), Color::Red, 0.0f, true);
    }
}
</code></pre></section>
</div>
<h2 id="example-using-layer-mask">Example Using Layer Mask</h2>
<p>Frequently you want a raycast to start from the player&#39;s position, however, such a raycast will instantly detect the player&#39;s collider. The correct way of solving this is to use the <a href="../editor/game-settings/layers-and-tags-settings.html">layers feature</a>.</p>
<p>To do so, assign a different layer to the player and colliders. You can also assign different layers to different groups of colliders. Then, in the raycast function, set the <code>layerMask</code> accordingly. The layer mask uses one bit for each layer. For example, to only check collisions with colliders from layer 3, you would typically use <code>1 &lt;&lt; 3</code> as the layer mask. Use <code>LayersMask</code> structure to pick the selection of layers via editor popup.</p>
<div class="tabGroup" id="tabgroup_Kfl9wdZikS-1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_Kfl9wdZikS-1_code-csharp" role="tab" aria-controls="tabpanel_Kfl9wdZikS-1_code-csharp" data-tab="code-csharp" tabindex="0" aria-selected="true">C#</a>
</li>
<li role="presentation">
<a href="#tabpanel_Kfl9wdZikS-1_code-cpp" role="tab" aria-controls="tabpanel_Kfl9wdZikS-1_code-cpp" data-tab="code-cpp" tabindex="-1">C++</a>
</li>
</ul>
<section id="tabpanel_Kfl9wdZikS-1_code-csharp" role="tabpanel" data-tab="code-csharp">
<pre><code class="lang-cs">public LayersMask Layers;

public override void OnUpdate()
{
    if (Physics.RayCast(Actor.Position, Actor.Direction, out RayCastHit hit, float.MaxValue, Layers))
    {
        DebugDraw.DrawSphere(new BoundingSphere(hit.Point, 50), Color.Red);
    }
}
</code></pre></section>
<section id="tabpanel_Kfl9wdZikS-1_code-cpp" role="tabpanel" data-tab="code-cpp" aria-hidden="true" hidden="hidden">
<pre><code class="lang-cpp">#include &quot;Engine/Core/Types/LayersMask.h&quot;
#include &quot;Engine/Physics/Physics.h&quot;
#include &quot;Engine/Debug/DebugDraw.h&quot;

API_FIELD() LayersMask Layers;

void MyScript::OnUpdate() override
{
    RayCastHit hit;
    if (Physics::RayCast(GetActor()-&gt;GetPosition(), GetActor()-&gt;GetDirection(), hit, MAX_float, Layers))
    {
        DEBUG_DRAW_SPHERE(BoundingSphere(hit.Point, 50), Color::Red, 0.0f, true);
    }
}
</code></pre></section>
</div>
<h2 id="example-raycast-with-mesh-data-access">Example raycast with mesh data access</h2>
<p>If Raycast hit mesh collider or terrain it contains <code>FaceIndex</code> (an index of the face that was hit) and <code>UV</code> (barycentric coordinates of hit triangle). Those can be used to access the geometry data that was used to cook the hit collider. One example would be reading the vertex colors or normal vectors of the hit mesh geometry.</p>
<p>To do so you can use <code>CollisionData.GetModelTriangle</code> method which converts the face index of the mesh collider into index of the geometry that was used for cooking collision. It&#39;s supported only for collision data built as triangle mesh and without <code>ConvexMeshGenerationFlags.SuppressFaceRemapTable</code> flag set.</p>
<p>After retrieving the source mesh and its triangle index you can get the index and vertex buffers to read the data of the hit triangle. If the data is accessed frequently for similar meshes, try to use caching or use C++ API that contains improved data access and internal cache by default.</p>
<div class="tabGroup" id="tabgroup_Kfl9wdZikS-2">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_Kfl9wdZikS-2_code-csharp" role="tab" aria-controls="tabpanel_Kfl9wdZikS-2_code-csharp" data-tab="code-csharp" tabindex="0" aria-selected="true">C#</a>
</li>
<li role="presentation">
<a href="#tabpanel_Kfl9wdZikS-2_code-cpp" role="tab" aria-controls="tabpanel_Kfl9wdZikS-2_code-cpp" data-tab="code-cpp" tabindex="-1">C++</a>
</li>
</ul>
<section id="tabpanel_Kfl9wdZikS-2_code-csharp" role="tabpanel" data-tab="code-csharp">
<pre><code class="lang-cs">public override void OnUpdate()
{
    // Try to hit something with a mouse click
    if (!Input.GetMouseButtonDown(MouseButton.Left))
        return;
    var pos = Input.MousePosition;
    var ray = Camera.MainCamera.ConvertMouseToRay(pos);
    if (!Physics.RayCast(ray.Position, ray.Direction, out var hit))
        return;

    Debug.Log(&quot;Hit UV: &quot; + hit.UV);

    // Check if mouse clicked on a mesh collider
    if (hit.Collider is MeshCollider meshCollider)
    {
        // Read the source geometry triangle based on the hit face index
        if (meshCollider.CollisionData.GetModelTriangle(hit.FaceIndex, out var meshBase, out var triangle))
        {
            Debug.Log(&quot;Hit mesh: &quot; + (meshBase != null ? meshBase.ModelBase.Path : &quot;&lt;null&gt;&quot;));
            Debug.Log(&quot;Hit triangle: &quot; + triangle);

            if (meshBase is Mesh mesh)
            {
                // Access static mesh data
                var accessor = new MeshAccessor();
                if (accessor.LoadMesh(mesh))
                {
                    Debug.LogError(&quot;Failed to get mesh data&quot;);
                    return;
                }

                // Get the hit triangle data
                var indexStream = accessor.Index();
                var i0 = indexStream.GetInt((int)triangle * 3 + 0);
                var i1 = indexStream.GetInt((int)triangle * 3 + 1);
                var i2 = indexStream.GetInt((int)triangle * 3 + 2);

                // Interpolate normal of the triangle using the barycentric coordinate of the hit
                var normalStream = accessor.Normal();
                var n0 = normalStream.GetFloat3(i0);
                var n1 = normalStream.GetFloat3(i1);
                var n2 = normalStream.GetFloat3(i2);
                MeshAccessor.UnpackNormal(ref n0);
                MeshAccessor.UnpackNormal(ref n1);
                MeshAccessor.UnpackNormal(ref n2);
                var n = n0 * (1.0f - hit.UV.X - hit.UV.Y) + n1 * hit.UV.X + n2 * hit.UV.Y;

                // Transform mesh data into world-space
                var positionStream = accessor.Position();
                n = Vector3.Normalize(n);
                var t = hit.Collider.Transform;
                n = t.TransformDirection(n);
                var p0 = t.LocalToWorld(positionStream.GetFloat3(i0));
                var p1 = t.LocalToWorld(positionStream.GetFloat3(i1));
                var p2 = t.LocalToWorld(positionStream.GetFloat3(i2));

                // Display hit geometry normal and the triangle
                DebugDraw.DrawTriangle(p0, p1, p2, Color.Green.AlphaMultiplied(0.5f), 10000);
                DebugDraw.DrawLine(hit.Point, hit.Point + n * 30.0f, Color.Red, 10000);
            }
        }
    }
}
</code></pre></section>
<section id="tabpanel_Kfl9wdZikS-2_code-cpp" role="tabpanel" data-tab="code-cpp" aria-hidden="true" hidden="hidden">
<pre><code class="lang-cpp">#include &quot;Engine/Core/Log.h&quot;
#include &quot;Engine/Input/Input.h&quot;
#include &quot;Engine/Physics/Physics.h&quot;
#include &quot;Engine/Level/Actors/Camera.h&quot;
#include &quot;Engine/Physics/Colliders/MeshCollider.h&quot;
#include &quot;Engine/Graphics/Models/MeshAccessor.h&quot;
#include &quot;Engine/Debug/DebugDraw.h&quot;

void MyScript::OnUpdate() override
{
    // Try to hit something with a mouse click
    if (!Input::GetMouseButtonDown(MouseButton::Left))
        return;
    auto pos = Input::GetMousePosition();
    auto ray = Camera::GetMainCamera()-&gt;ConvertMouseToRay(pos);
    RayCastHit hit;
    if (!Physics::RayCast(ray.Position, ray.Direction, hit))
        return;

    LOG(Info, &quot;Hit UV: {}&quot;, hit.UV);

    // Check if mouse clicked on a mesh collider
    if (const auto* meshCollider = Cast&lt;MeshCollider&gt;(hit.Collider))
    {
        // Read the source geometry triangle based on the hit face index
        MeshBase* meshBase;
        uint32 triangle;
        if (meshCollider-&gt;CollisionData-&gt;GetModelTriangle(hit.FaceIndex, meshBase, triangle))
        {
            LOG(Info, &quot;Hit mesh: {}&quot;, meshBase ? meshBase-&gt;GetModelBase()-&gt;GetPath() : TEXT(&quot;&lt;null&gt;&quot;));
            LOG(Info, &quot;Hit triangle: {}&quot;, triangle);

            if (auto* mesh = Cast&lt;Mesh&gt;(meshBase))
            {
                // Access static mesh data
                MeshAccessor accessor;
                if (accessor.LoadMesh(mesh))
                {
                    LOG(Error, &quot;Failed to get mesh data&quot;);
                    return;
                }

                // Get the hit triangle data
                auto indexStream = accessor.Index();
                auto i0 = indexStream.GetInt(triangle * 3 + 0);
                auto i1 = indexStream.GetInt(triangle * 3 + 1);
                auto i2 = indexStream.GetInt(triangle * 3 + 2);

                // Interpolate normal of the triangle using the barycentric coordinate of the hit
                auto normalStream = accessor.Normal();
                auto n0 = normalStream.GetFloat3(i0);
                auto n1 = normalStream.GetFloat3(i1);
                auto n2 = normalStream.GetFloat3(i2);
                MeshAccessor::UnpackNormal(n0);
                MeshAccessor::UnpackNormal(n1);
                MeshAccessor::UnpackNormal(n2);
                auto n = n0 * (1.0f - hit.UV.X - hit.UV.Y) + n1 * hit.UV.X + n2 * hit.UV.Y;

                // Transform mesh data into world-space
                auto positionStream = accessor.Position();
                n = Vector3::Normalize(n);
                auto t = hit.Collider-&gt;GetTransform();
                n = Vector3::Transform(n, t.Orientation);
                auto p0 = t.LocalToWorld(positionStream.GetFloat3(i0));
                auto p1 = t.LocalToWorld(positionStream.GetFloat3(i1));
                auto p2 = t.LocalToWorld(positionStream.GetFloat3(i2));
                auto p2 = t.LocalToWorld(v02.Position);

                // Display hit geometry normal and the triangle
                DEBUG_DRAW_TRIANGLE(p0, p1, p2, Color::Green.AlphaMultiplied(0.5f), 10000, true);
                DEBUG_DRAW_LINE(hit.Point, hit.Point + n * 30.0f, Color::Red, 10000, true);
            }
        }
    }
}
</code></pre></section>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/FlaxEngine/FlaxDocs/blob/ee97ad993bcca5f2b72f19accf8f8abf71adb84d/manual/physics/raycasting.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright © 2012-2024 Wojciech Figat
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
